<!DOCTYPE html><html lang="ko"> <head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="icon" href="/blog/favicon.ico" sizes="any"><title>P/Invoke</title><link rel="stylesheet" href="/blog/_astro/index.D-IOTMtv.css"></head> <body class="page-reader"> <script>(function(){const withRects = false;

  (() => {
    const root = document.documentElement;
    const fixed = (globalThis).__E2E_FIXED_BG__ === true;

    const palettes = ['blue', 'plum', 'forest', 'rust'];
    root.dataset.palette = fixed
      ? 'blue'
      : palettes[Math.floor(Math.random() * palettes.length)];

    if (!withRects) return;

    const setPosPx = (name, x, y) => {
      root.style.setProperty(name + '-x', `${x}px`);
      root.style.setProperty(name + '-y', `${y}px`);
    };

    const randInt = (min, max) => Math.floor(Math.random() * (max - min + 1)) + min;

    const apply = () => {
      const vw = Math.max(320, Math.floor(window.innerWidth || 0));
      const vh = Math.max(480, Math.floor(window.innerHeight || 0));
      const margin = 12;

      const px = (value) => {
        const n = Number.parseFloat(String(value).trim());
        return Number.isFinite(n) ? n : 0;
      };

      const styles = getComputedStyle(root);
      const sizes = {
        s: { w: px(styles.getPropertyValue('--rect-s-w')), h: px(styles.getPropertyValue('--rect-s-h')) },
        m: { w: px(styles.getPropertyValue('--rect-m-w')), h: px(styles.getPropertyValue('--rect-m-h')) },
        l: { w: px(styles.getPropertyValue('--rect-l-w')), h: px(styles.getPropertyValue('--rect-l-h')) }
      };

      const place = (size, minY = margin) => {
        const maxX = Math.max(margin, vw - size.w - margin);
        const maxY = Math.max(minY, vh - size.h - margin);
        return {
          x: randInt(margin, maxX),
          y: randInt(minY, maxY),
          w: size.w,
          h: size.h
        };
      };

      if (fixed) {
        // Deterministic layout for Playwright.
        const s1 = { x: 24, y: Math.min(280, vh - 80), ...sizes.s };
        const s2 = { x: Math.max(24, vw - 140), y: 72, ...sizes.s };
        const s3 = { x: Math.max(24, vw - 160), y: Math.max(72, vh - 160), ...sizes.s };
        const m = { x: Math.max(24, vw - 320), y: Math.floor(vh * 0.4), ...sizes.m };
        const l = { x: Math.max(24, vw - 520), y: Math.floor(vh * 0.72), ...sizes.l };

        setPosPx('--rect-s1', s1.x, s1.y);
        setPosPx('--rect-s2', s2.x, s2.y);
        setPosPx('--rect-s3', s3.x, s3.y);
        setPosPx('--rect-m', m.x, m.y);
        setPosPx('--rect-l', l.x, l.y);
        return;
      }

      // Overlap is allowed (collage feel). Keep a tiny bit of calm at the very top.
      const topPad = 56;
      const large = place(sizes.l, topPad);
      const medium = place(sizes.m, topPad);
      const s1 = place(sizes.s, topPad);
      const s2 = place(sizes.s, topPad);
      const s3 = place(sizes.s, topPad);

      setPosPx('--rect-l', large.x, large.y);
      setPosPx('--rect-m', medium.x, medium.y);
      setPosPx('--rect-s1', s1.x, s1.y);
      setPosPx('--rect-s2', s2.x, s2.y);
      setPosPx('--rect-s3', s3.x, s3.y);
    };

    // Run after layout so we can avoid the real content column.
    if (document.readyState === 'complete' || document.readyState === 'interactive') {
      requestAnimationFrame(apply);
    } else {
      window.addEventListener('DOMContentLoaded', () => requestAnimationFrame(apply), { once: true });
    }

    // If Astro View Transitions are enabled later, re-randomize on navigation.
    document.addEventListener('astro:page-load', () => requestAnimationFrame(apply));
  })();
})();</script> <main> <article class="reader"> <a class="reader-home" href="/blog/" aria-label="archives로">← archives</a> <h1 data-testid="reader-title" lang="en">P/Invoke</h1> <time class="reader-date" data-testid="reader-date" datetime="2026-02-04">2026-02-04</time> <div data-testid="reader-content"> <h3> P/Invoke (Platform Invoke) </h3><p> managed 코드에서 unmanaged 라이브러리 호출을 지원하는 닷넷 기술이다. 정확한 표현은 아니지만, 쉽게 후려쳐서 이야기하면 C#에서 C/C++로 만든 동적 라이브러리를 호출할 수 있다. C#의 System과 System.Runtime.InteropServices 네임스페이스에 정의돼 있고, 동적 라이브러리(.dll, .so, .dylib 등)에 정의된 함수, 콜백, 구조체 등에 접근하는 것이 가능하다. 닷넷 7 이전에는 DllImport Attribute와 extern 키워드를 혼합해서 사용했지만, 7부터는 LibraryImport Attribute와 partial 키워드를 섞어서 쓰는 방식도 지원한다. 둘 다 IL stub을 생성해서 마샬링과 SetLastError 등의 전후처리를 하는 건 동일한데, LibraryImport는 AOT 지원을 위해서 등장했다고 한다. Unity에서는 DllImport만 사용할 수 있다. </p><h3> 라이브러리 검색 (Resolving) </h3><p> 기본적으로는 [DllImport(&quot;kernel32.dll&quot;)] 과 같이 작성한다. 확장자는 안 붙여도 되며, 크로스플랫폼을 위해 확장자를 안 붙이는 것이 권장되는 모양이다. 라이브러리 이름만 적으면 System32나 현재 위치 등 일반적인 경로 찾기 순서와 동일한 것 같고, 절대경로도 사용할 수 있다. NativeLibrary.SetDllImportResolver() 함수를 사용해 사용자 정의 리졸브도 가능하다. </p><h3> 마샬링 (Marshalling) </h3><p> managed 코드와 unmanaged 코드 사이의 자료형 변환 프로세스다. 기본적으로 닷넷 System 자료형과 C/C++ 네이티브 형식 간 암시적 변환이 가능하다. 파라미터 및 반환형에 MarshalAs Attribute로 명시적 변환도 가능하다. 함수에 콜백을 전달해야 하는 경우 delegate를 사용하고, 클래스/구조체 이름 상관없이 순서에 맞추려면 StructLayout Attribute 사용한다. 자세한 내용은 아래 링크 확인. </p><p> <a href="https://learn.microsoft.com/ko-kr/dotnet/standard/native-interop/type-marshalling#default-rules-for-marshalling-common-types" target="_blank" rel="noreferrer noopener"> 기본적인 형 변환 </a> </p><p> <a href="https://learn.microsoft.com/ko-kr/dotnet/standard/native-interop/customize-struct-marshalling" target="_blank" rel="noreferrer noopener"> 자세한 형 변환 </a> </p><h3> 에러 핸들링 </h3><p> SetLastError = true를 전달하면 Marshal.GetLastPInvokeError()로 에러를 확인할 수 있다. </p><h3> 문자열 </h3><p> C#은 기본적으로 UTF-16이기 때문에 주의해야 한다. DllImport에서는 CharSet, LibraryImport에서는 StringMarshalling으로 명시할 수 있다. 가능하면 UTF-8을 쓰자. </p><h3> 함수 호출 규약 </h3><p> DllImport에서는 CallingConvention, LibraryImport에서는 UnmanagedCallConv Attribute로 함수 호출 규약을 명시할 수 있다. AMD64 아키텍처에서는 의미 없지만, x86에서는 cdecl, stdcall, fastcall 등을 지정해줘야 한다. </p> </div> <a class="reader-home" href="/blog/" aria-label="archives로">← archives</a> </article> </main> </body></html>